<!DOCTYPE html>
<html>

<head>
    <script src="./d3.v3.min.js" charset="utf-8"></script>
<style>
.area {
    fill: deepskyblue;
    stroke-width: 0;
	opacity: 0.2;
}

#introduction {
  position: relative;
  width: 1500px;
  margin-bottom = 40px;

}

#pad2 {
  position: relative;
  width: 950px;
  height: 10px;
}

#pad3 {
  position: relative;
  width: 950px;
  height: 20px;
}
#pad4 {
  position: relative;
  width: 950px;
  height: 20px;
}
#introduction h4 {
  margin-top:3em;
  margin-bottom: 1.5em;
    margin-left: 14px;
  font-family: 'Architects Daughter', 'Helvetica Neue', Helvetica, Arial, serif;
  font-size: 15px;
  font-weight: bold;
  color: #474747;
  text-indent: 3px;
}
#introduction p {
  margin-top:0.5em;
  margin-bottom: 0.5em;
  margin-left: 14px;
  font-family: 'Architects Daughter', 'Helvetica Neue', Helvetica, Arial, serif;
  font-size: 15px;
  color: Black;
  text-align: justify;
  line-height:18px;
}
#lancement {
  position: relative;
  width: 1300px;
  margin-top= 0px;
  margin-bottom = 10px;
}
#lancement h4 {
  margin-top:3em;
  margin-bottom: 1.5em;
    margin-left: 14px;
  font-family: 'Architects Daughter', 'Helvetica Neue', Helvetica, Arial, serif;
  font-size: 15px;
  font-weight: bold;
  color: #474747;
  text-indent: 3px;
}

#lancement h1 {
	padding: 0px 0px 5px 0px;
}
#lancement p {
  margin-top:1em;
  margin-bottom: 0.5em;
  margin-left: 14px;
  font-family: 'Architects Daughter', 'Helvetica Neue', Helvetica, Arial, serif;
  font-size: 15px;
  color: Black;
  text-align: justify;
  line-height:18px;
}
.axis path,
.axis line {
	fill: none;
	stroke: black;
	stroke-width: 1;
	shape-rendering: crispEdges;
}
.axis text {
    font-family: sans-serif;
    font-size: 11px;
}

#zone1 {
  position: relative;
  width: 1500px;
  height: 60px;
}
#zone1 h4 {
  margin-top:3em;
  margin-bottom: 1.5em;
    margin-left: 14px;
  font-family: 'Architects Daughter', 'Helvetica Neue', Helvetica, Arial, serif;
  font-size: 15px;
  font-weight: bold;
  color: #474747;
  text-indent: 3px;
}
#zone1 p {
  margin-top:0.5em;
  margin-bottom: 0.5em;
  margin-left: 14px;
  font-family: 'Architects Daughter', 'Helvetica Neue', Helvetica, Arial, serif;
  font-size: 15px;
  color: Black;
  text-align: justify;
  line-height:18px;
}
#zone12 {
  position: relative;
  width: 1500px;
  height: 30px;
}
#zone12 h4 {
  margin-top:1em;
  margin-bottom: 2em;
    margin-left: 14px;
  font-family: 'Architects Daughter', 'Helvetica Neue', Helvetica, Arial, serif;
  font-size: 15px;
  font-weight: bold;
  color: #474747;
  text-indent: 3px;
}
#zone12 p {
  margin-top:0.5em;
  margin-bottom: 0.5em;
  margin-left: 14px;
  font-family: 'Architects Daughter', 'Helvetica Neue', Helvetica, Arial, serif;
  font-size: 15px;
  color: Black;
  text-align: justify;
  line-height:18px;
}
svg12{
  opacity: 1;
  width: 900px;
  height: 20px;
    margin-left: 14px;
} 
#zone13 {
  position: relative;
  width: 1500px;
  height: 30px;
}
#viz {
  position: relative;
  margin-top = 20px;
    margin-left: 14px;
  width: 1160px;
  height: 400px;
}
#zone2 {
  position: relative;
  width: 1500px;
  height: 260px;
}
#zone2 h4 {
  margin-top:3em;
  margin-bottom: 1.5em;
  font-family: 'Architects Daughter', 'Helvetica Neue', Helvetica, Arial, serif;
  font-size: 15px;
  font-weight: bold;
  color: #474747;
  text-indent: 14px;
}
#zone2 p,text {
  margin-top:0.5em;
  margin-bottom: 0.5em;
  margin-left: 14px;
  font-family: 'Architects Daughter', 'Helvetica Neue', Helvetica, Arial, serif;
  font-size: 15px;
  color: Black;
  text-align: justify;
  line-height:18px;
}

#zone3 {
  position: relative;
  width: 1300px;
  height: 800px;
}
#zone3 h4 {
  margin-top:3em;
  margin-bottom: 1.5em;
  font-family: 'Architects Daughter', 'Helvetica Neue', Helvetica, Arial, serif;
  font-size: 15px;
  font-weight: bold;
  color: #474747;
  text-indent: 14px;
}
#zone3 p,text {
  margin-top:0.5em;
  margin-bottom: 0.5em;
  margin-left: 14px;
  font-family: 'Architects Daughter', 'Helvetica Neue', Helvetica, Arial, serif;
  font-size: 15px;
  color: Black;
  text-align: justify;
  line-height:18px;
}
</style>

</head>
<div id="introduction"></div>

<div id="lancement">
<h1 align="center"> ALGORITHME DES K-MEANS  </h1>
<p><br /><br />L'algorithme des K-means permet d'identifier des groupes de points similaires. Contrairement aux algorithmes de classification il n'a pas besoin que des labels soient assignées aux mesures pour apprendre. Il utilise uniquement la similarité qu'il interprète comme une distance entre les points dans un espace à p dimensions, p étant le nombre de variables qui décrivent les mesures, nous parlerons alors de clusterisation plutôt que de classification.
</p>  
<p> Pour la démonstration, nous associerons des classes aux groupes de points afin d'évaluer la performance du K-means. Cette performance correspond à la "pureté" des regroupements trouvés par le K-means. Si un regroupement est constitué largement majoritairement d'une classe alors sa pureté sera grande, en revanche si le regroupement est constitué de plusieurs classes équi-réparties la pureté sera faible.
</p> 
<p>Nous observerons que la performance du K-means varie en fonction de la structure du système de points et du nombre de centroïdes choisis au départ. Dans la pratique on lance plusieurs fois l'algorithme en faisant varier ce nombre et on retient le meilleur résultat (Somme des puretés pondérées sur toute la partition)
</p> 
 
</div>
<div id="pad2"><br /><br /></div>
<div id="zone1">	
	<div id="zone12"></div>
	<div id="zone13"></div>
</div>
<div id="viz"></div>
<div id="pad3"><br /><br /></div>
<div id="zone2"></div>
<div id="pad4"></div>
<div id="zone3"></div>
<body>
   <script charset ="utf-8" type="text/javascript">
	
	var svg0 = d3.select("#introduction").append("svg0")
    .attr("width", 900)
    .attr("height", 70)
	.style("border", 1)
	.attr("class", "graph-svg-component");
	   
	var svg1 = d3.select("#zone12").append("svg1")
    .attr("width", 500)
    .attr("height", 30)
	.style("border", 1)
	.attr("class", "graph-svg-component");
	
	var svg12 = d3.select("#zone13").append("svg12")
    .attr("width", 1160)
    .attr("height", 30)
	.style("border", 1)
	.attr("class", "graph-svg-component");
	
	var svg = d3.select("#viz").append("svg")
    .attr("width", 1050)
    .attr("height", 400)
	.style("border", 1)
	.attr("class", "graph-svg-component");
	   
	var svg2 = d3.select("#lancement").append("svg2")
    .attr("width", 900)
    .attr("height", 650)
	.style("border", 1)
	.attr("class", "graph-svg-component");
	

	
   	var numPoints = 100;	// default selection is 100 points
	var numCentroides = 3; 
	var bubbleChart = [];	
	var Yn = [];
	var Xn = [[]];
	var P = [];		
	var slope = 0;
	var	lineoffset = 0;
	
	var Etat_points = "Choix_en_cours";
	var valide = "valide";
	var test = 0;
	var Ok_pour_perceptron = "KO";
	var W = [[]];
	W[0] =  [0,0,0,0];
	var slopeW = 0;
	var	lineoffsetW = 0;
	var	IT = 0;
	var	XRn = 0;
	var	YRn = 0;
	var YnRn = 0;
	var	Yn_w = [];
	var	Wcost = 0;
	var Wcostmin = 5000;
	var TabWcostmin = [];
	var tabl1=[];
	var paddingy = 27;
	var paddingx = 27;
	var hx = 300;
	var hy = 300;
	var Decalage_right_courbeCout = 550;
	var formatAsPercentage = d3.format(".1%");
	var w = 300;
	var Costdataset = [];
	var MaxIT = 1000;
	var firsttime = "OK";
	var j=0;
	var Point_x = 0;
	var Point_y = 0;
	var blackpoint_ordonnee = "KO";
	var blackpoint_abscisse  = "KO";
	var Lambda = 0.1;
	var coord_origine  = [];
	var centroide = [[0,0]];
	var affectation_points_centroides = [];	
	var convergence = "ko"
	var oneshot = "ko"
	
	function zeroFilledArray(size) {
		return new Array(size + 1).join('0').split('');
	}
	

	function Math_sign(ValeurASigner){
	
		if (ValeurASigner == 0){
			
			return 0;
			
			}
		else{
			if(ValeurASigner > 0){
			return 1;
			}
			else{
			return -1;
			}
		
		}
	
	}

	function affichage_cout(){
		
		//ici initialiser les variables pour afficher données et axes
		Costdataset = [];
		d3.selectAll("g").remove();
		d3.select("#p5").remove();
			
		for (var i = 0; i < W.length; i++) { 
			Costdataset.push([W[i][3]*200,i]);// la valeur du cout est multiplie par 200 car elle correspondra ) l'affichage à un nombre de pixels qui doit être une quantité visible, l'echelle verticale est de 0 à 80%
			//d3.select("svg2").append("p").text("Costdataset[0] = "+Costdataset[i][0]+"Costdataset[1] = "+i);
		}
				
		var xScale = d3.scale.linear()
				.domain([0, d3.max(Costdataset, function(d) { return (d[1]); })])
				.range([0, d3.max(Costdataset, function(d) { return (d[1])*1.5; })]);

		var yScale = d3.scale.linear()
				.domain([0, 0.8])
				.range([hy - paddingy, paddingy]);
				
		var xAxis = d3.svg.axis()
                .scale(xScale)
                .orient("bottom")
				.ticks(3);
				  
		var yAxis = d3.svg.axis()
                .scale(yScale)
                .orient("left")
				.tickFormat(formatAsPercentage);
				  
		svg.append("g")
				.attr("class", "axis")  // Assigne la classe "axis"
				.attr("transform", "translate("+Decalage_right_courbeCout + "," + (hx - paddingx) + ")")
				.call(xAxis);
				
		svg.append("text")      // text label for the x axis
			.attr("x", Decalage_right_courbeCout + 50 )
			.attr("y", hx+15 )
			//.style("text-anchor", "middle")
			.text("Itérations");
					
		svg.append("g")
			.attr("class", "axis")
			.attr("transform", "translate("+ Decalage_right_courbeCout + ",0)")
			.call(yAxis);
				
		svg.append("text")
			.attr("transform", "rotate(-90)")
			.attr("y",Decalage_right_courbeCout - (3*paddingx))
			.attr("x",0- hx/2-paddingy)
			.attr("dy", "1em")
			.text("Taux d'erreur");
				
 				  
		var lineFunction = d3.svg.line()
                          .x(function(d) { return (d[1]); })
                          .y(function(d) { return (hx-paddingx-d[0]); })
                          .interpolate("linear");		  
		
		svg.append("path")
			.attr("id", "costpath")
			.attr("d", lineFunction(Costdataset))
			.attr("transform", "translate("+ Decalage_right_courbeCout + ",0)")
            .attr("stroke", "lightblue")
			.attr("opacity", 1)
            .attr("stroke-width", 1)
            .attr("fill", "none");		  
			
		d3.select("svg").append("text").attr("fill", "red").attr("id","p5").text("Taux d'erreur minimum: "+ Wcostmin.toFixed(5)).attr("font-size", "15px").attr("transform", "translate("+ (Decalage_right_courbeCout+150) + ","+(hx +100)+")");

			
	}
	
	function KMeans_Pasapas() {		
		d3.select("#btn_perpOS").remove()
	    Affectation_centroides();  	       			
		if (convergence == "ok"){
		d3.select("svg1").append("button")
				.attr("id","btn0")
				.attr("value","PLAY")
				.text("Définir un nouveau jeu de points")
				.on("click", Lancer_Kmeans);	
			
		}
	}
				
	
	function FindRandomPoint(){
		var tabl=[];
		index = getRandomInt(1, Xn.length) -1;
		tabl[0] = Xn[index][0];
		tabl[1] = Xn[index][1];
		tabl[2] = Xn[index][2];
		return tabl;
	}


	
	function Compute_new_centroides(){
		for (var j = 0 ; j < numCentroides; j++){
			cpt_nbr_pts = 0;
			Cent_x = 1;
			Cent_y = 1;
			for (var i = 0; i < numPoints; i++){
				if(affectation_points_centroides[i] == j){
					
					Cent_x = Cent_x + Xn[i][0];
					Cent_y = Cent_y + Xn[i][1];
					cpt_nbr_pts = cpt_nbr_pts + 1;
				}			
			}
			if (cpt_nbr_pts != 0){
				Cent_x = Cent_x/cpt_nbr_pts ;
				Cent_y = Cent_y/cpt_nbr_pts ;	
			}
			
			
			//verification du critère de convergence, fin des iterations
			if (( Math.abs(centroide[j][0] - Cent_x) < 1.)&&(Math.abs(centroide[j][1] - Cent_y ) < 1.)){
				
				d3.select("svg2").append("p").attr("id","p_p42").text( "Les centroïde sont figés, le K-means a identifié les regroupements homogènes.");
				d3.select("#p2").remove(); //Suppression paragraphe - Phase apprentissage
				d3.select("#p5").text("Indice de pureté et taux d'erreurs d'apprentissage: ");

				
				d3.select("#btn_perpOS").remove();
				d3.select("#btn_perpIT").remove();	
				d3.select("#nValueC").remove();
				d3.selectAll("label").remove();	
				d3.select("#buttonChoixCentroides").remove();
				convergence = "ok"
				
			}
			else {
				
				centroide[j][0] = Cent_x;
				centroide[j][1] = Cent_y;
			}
		}
	
	}
	
	function Affectation_centroides(){
		if (debut == "ok"){
			for(var i=0;i < numCentroides;i++){	
			
				var c_x = getRandomInt(5,355);
				var c_y = getRandomInt(5,355);
				if (i==0){
					centroide[i][0] = c_x;
					centroide[i][1] = c_y;
				}
				else { centroide.push([c_x,c_y]);}
			
			}	
			
			debut = "ko";
		}
	
		
		d3.selectAll("path").remove();
		d3.select("#blkpt").remove();
		d3.select("#blkpt").remove();
		d3.select("#blkpt").remove();
		d3.select("#btn0").remove();
		d3.select("#btn1").remove();
		d3.select("#p_p42").remove()

		distance = [];
		for (var i = 0; i < numPoints; i++){
			distance = [];
			for (var j = 0 ; j < numCentroides; j++){
				distance[j] = Math.sqrt(Math.pow(Xn[i][0] - centroide[j][0],2) + Math.pow(Xn[i][1] - centroide[j][1],2));	
			}		
			affectation_points_centroides[i] = distance.indexOf(Math.min.apply(Math, distance));
		}
		
		//affichage des affectations points- centroides
		
		for (var i = 0; i < numPoints; i++){

			var TabDataSet_centroides = [[ Xn[i][0],Xn[i][1]],[ centroide[affectation_points_centroides[i]][0] ,centroide[affectation_points_centroides[i]][1]], ]
		 		
			var lineFunction = d3.svg.line()
							.x(function(d) { return (d[0] ); })
							.y(function(d) { return (d[1] ); })
							.interpolate("linear");		
	
			svg.append("path")
				.attr("id", "path_centroides")
				.attr("d", lineFunction(TabDataSet_centroides))
				.attr("stroke", "purple")
				.attr("opacity", 0.5)
				.attr("stroke-width", 0.5)
				.attr("fill", "none");	
				
		}
		
					
		d3.selectAll("svg")
			.append("circle")
			.attr("id","blkpt")
			.style("stroke", "black")
			.style("fill", "orange")
			.style("opacity", 1)
			.attr("r", 4)
			.attr("cx",centroide[0][0])
			.attr("cy",centroide[0][1]);
		
		d3.selectAll("svg")
			.append("circle")
			.attr("id","blkpt")
			.style("stroke", "black")
			.style("fill", "orange")
			.style("opacity", 1)
			.attr("r", 4)
			.attr("cx",centroide[1][0])
			.attr("cy",centroide[1][1]);
		
		d3.selectAll("svg")
			.append("circle")
			.attr("id","blkpt")
			.style("stroke", "black")
			.style("fill", "orange")
			.style("opacity", 1)
			.attr("r", 4)
			.attr("cx",centroide[2][0])
			.attr("cy",centroide[2][1]);
				
		Compute_new_centroides();
		
	}
	
	function centroid_positionning(){
		convergence = "ko"
		debut = "ok";

		while (convergence == "ko") {
			Affectation_centroides();  
		}
		
		d3.select("svg1").append("button")
					.attr("id","btn0")
					.attr("value","PLAY")
					.text("Définir un nouveau jeu de points")
					.on("click", Lancer_Kmeans);	
					
	    if(oneshot == "ok"){

			d3.select("svg12").append("button")
					.attr("id","btn1")
					.attr("value","PLAY2")
					.text("Relancer K-Means (nouveaux centroides initiaux)")
					.on("click", centroid_positionning);			
		}
		
	}
	
	function Kmeans_Oneshot() {				
		oneshot = "ok"
		d3.select("#btn_perpIT").remove();	
		centroid_positionning()
			
	}
	
	
	function Create2DArray(rows) {
		var arr = [];

		for (var i=0;i<rows;i++) {
			arr[i] = [];
		}
		return arr;
	}
	function Etiquetage() {
        
		d3.select("svg2").append("p").attr("id","p_p3").text("Les points forment trois groupes différents, chaque classe correspond à une couleur");	
		
		for (var i = 0; i < Math.floor(numPoints/3); i++) {
			Xn[i][0] = bubbleChart[i][0];
			Xn[i][1] = bubbleChart[i][1];
			Xn[i][2] = '1'; 			
		}
			
		for (var i = Math.floor(numPoints/3); i < 2*Math.floor(numPoints/3); i++) {
			Xn[i][0] = bubbleChart[i][0];
			Xn[i][1] = bubbleChart[i][1];
			Xn[i][2] = '2' ;			
		}
		
		for (var i = 2*Math.floor(numPoints/3); i < numPoints; i++) {
			Xn[i][0] = bubbleChart[i][0];
			Xn[i][1] = bubbleChart[i][1];
			Xn[i][2] = '3' ;			
		}	
		
		var tb2 = d3.selectAll("circle").data(Xn); // selection des cercles et lien avec le tableau de valeurs Xn
		tb2.style("stroke", "black");
		tb2.style("stroke-width", 1);
		tb2.style("opacity",0.5);
		tb2.style("fill", function(d) { 
								if (d[2] == '1'){
									return "green";
								}
								else if (d[2] == '2'){
									return "deepskyblue";
									}
								else if (d[2] == '3'){
									return "yellow";
									}
							});
		tb2.attr("r", 2);
		tb2.attr("cx", function(d) { return d[0]; });
		tb2.attr("cy", function(d) { return d[1]; });


		
		
		d3.selectAll("#btn3").remove();				
		
		//Wo_init();
		d3.select("#p1").remove();	//suppression du texte "Preparation du jeu de donneés"
		d3.select("svg2").append("h4").attr("id","p6").text("Phase d'apprentissage").style("font-size", "17px");

		d3.select("#p1").remove();				
		d3.select("svg2").append("p").attr("id","p_a1").text( "L'algorithme des K-means ne connaît pas la classe des points, c'est ce qu'il doit trouver. Il ne connaît que l'emplacement des points (leurs coordonnées) et leur classe( représentée ici par leur couleur). Son principe de fonctionnement consiste à semer quelques points au hasard. Ce hasard n'est en fait qu'un semi hasard et beaucoup de recherches ont été faites pour identifier les bonnes règles de placement initial des ces points que nous appelerons les centroïdes.");
		d3.select("svg2").append("p").attr("id","p_a2").text( "On associe ensuite à chaque point le centroïde qui lui est le plus proche en distance. A cette étape nous obtenons une classification temporaire des points, chacun ayant son centroïde. Les centroïdes sont alors déplacés au niveau du centre de gravité de leur groupe de points respectifs. Cette procédure est répétée plusieurs fois et petit à petit les centroïdes coîncident avec les zones de forte densité cet espace multidimensionnel."); 
		d3.select("svg2").append("p").attr("id","p_a3").text( "Le procédé itératif s'achève lorsque les  centroïdes ne bougent plus ou très peu");
		d3.select("svg2").append("p").attr("id","p_a4").text( "L'option - K-means pas à pas- exécute une itération de l'algorithme a chaque click");
		d3.select("svg2").append("p").attr("id","p_a5").text( "L'option - K-means Automatique - exécute l'apprentissage complètement.");

		var nodeKM = document.createElement('div'); 
		nodeKM.innerHTML = '<br /><label for="nValueC" style="display: inline-block; width:225px; text-align: left; font-size: 15px; font-family: Arial; margin-left: 14px"> Choisir le nombre de centroïdes:    </label><input type="number" min="0" max="100" step="1" value="3" id="nValueC"><input value="valider" type="button"  onClick="add_centroide()" id="buttonChoixCentroides">';	
		document.getElementById('lancement').appendChild(nodeKM);				
		//if (IT == 0){d3.select("#btn_perpOS").remove();} //on supprime le bouton de choix K-means  automatique

		
		d3.select("svg12").append("button")
			.attr("id","btn_perpIT")
			.attr("value","K-Means pas a pas")
			.text("K-Means pas a pas");
				
		d3.select("#btn_perpIT")
			.on("click",function() {
				if(this.value == "K-Means pas a pas") {
					this.value = "Clicker pour itérer";
					d3.select(this).text("Clicker pour itérer");
					debut = "ok";
					KMeans_Pasapas();
				}
				else {
					KMeans_Pasapas();
				}		
			});
			
		d3.select("svg12").append("button")
			.attr("id","btn_perpOS")
			.style("margin-left","8px")					
			.attr("value","K-Means Automatique")
			.on("click", Kmeans_Oneshot)
			.text("K-Means Automatique");	
						
	}
        
	function getRandomInt(min, max) {
            return Math.floor(Math.random() * (max - min + 1)) + min;
    }
	
	function validation_point() {
			d3.select("svg12").append("button")
			.text("Valider les points")
			.attr("id","btn22")
			.on("click", removebutton_bnt2);
			
	}

	function removebutton_bnt2() {
		d3.select("#btn2").remove();//on supprime le bouton change de points
		d3.select(this).remove();//on supprime le bouton de validation de points
		d3.select("svg2").append("p").attr("id","p_p2").text( "Les points sont choisis au hasard mais dans une distribution normale, c'est ce qui permet de former des groupes plus ou moins distincts, ils représentent les enregistrements connus qui vont servir à l'apprentissage de K-means. ");	
		Etat_points = "valide";
				
				
		if(Etat_points == "valide"){
			d3.select("svg1").append("button")
				.attr("id","btn3")
				.on("click", Etiquetage)
				.text("Lancer l'étiquetage des points");
		}	
			
	}	
	// from http://bl.ocks.org/mbostock/4349187
	// Sample from a normal distribution with mean 0, stddev 1.
	function normal() {
		var x = 0,
        y = 0,
        rds, c;
		do {
			x = Math.random() * 2 - 1;
			y = Math.random() * 2 - 1;
			rds = x * x + y * y;
		} while (rds == 0 || rds > 1);
		c = Math.sqrt(-2 * Math.log(rds) / rds); // Box-Muller transform
		return x * c; // throw away extra sample y * c
	}	

	var runCircles = function() {
	
		d3.selectAll("circle").remove();
		bubbleChart = [];			
		
		CentreAx = getRandomInt(0,100);
		CentreAy = getRandomInt(10,350);
		
		CentreBx = getRandomInt(100,300);	
		CentreBy = getRandomInt(50,350);	
		
		CentreCx = getRandomInt(250,310);
		CentreCy = getRandomInt(10,350);

		for (var i = 0; i < Math.floor(numPoints/3); i++) {
						
			bubbleChart.push([Math.floor(CentreAx + 30*normal()), Math.floor( CentreAy + 40*normal())]);
		}	
			
		for (var i = Math.floor(numPoints/3); i < 2*Math.floor(numPoints/3); i++) {
			
			temp_Bx = Math.floor(CentreBx + 20*normal())
			
			bubbleChart.push([temp_Bx, Math.floor( CentreBy + 20*normal())]);
			
		}	
			
		for (var i = 2*Math.floor(numPoints/3); i < numPoints; i++) {

			temp_Cx = Math.floor(CentreCx + 30*normal())

			bubbleChart.push([temp_Cx, Math.floor( CentreCy + 45*normal())]);
			
		}	
	
		var tb = svg.selectAll("circle").data(bubbleChart);	   
		tb.enter()
			.append("circle")
			.style("stroke", "black")
			.style("fill", "black")
			.style("opacity", 0.5)
			.attr("r", 1)
			.attr("cx", function(d) { return d[0]; })
			.attr("cy", function(d) { return d[1]; });
			       
			 
		
	};
    //Draw a line

	
	function add_centroide(){
	
		if (document.getElementById('nValueC').value!='') 
		{
			numCentroides  = document.getElementById('nValueC').value;
		}
	
	}


			
	function add(){   
		
		if (document.getElementById('nValue').value!='') 
		{   			
			numPoints  =document.getElementById('nValue').value;
			d3.select("svg2").append("p").attr("id","p_p4").text("Nombre de points: "+numPoints);
			d3.select("#nValue").remove();
			d3.selectAll("label").remove();	
			d3.select("#buttonChoixPoints").remove();
			Xn = Create2DArray(numPoints);
			
			d3.select("svg1").append("button")
				.attr("id","btn2")
				.attr("value","Choisir les points")
				.text("Choisir les points");
			
			d3.select("#btn2")
			.on("click",function() {
				if(this.value == "Choisir les points") {
					this.value = "Changer les points";
					d3.select(this).text("Changer les points");
					runCircles();			
					validation_point();		
					d3.select("#pnumPoints").remove();
					//d3.select("svg2").append("p").attr("id","p_p5").text("Nombre de points: "+numPoints);
					
				}
				else {
					runCircles();
				}
			});
			
		}
		
		

	}
	
			
	function add_abscisse(){   
		if (document.getElementById('abscisse').value!='') { 
			Point_x = document.getElementById('abscisse').value;											
				blackpoint_abscisse = "OK";
				drawblackpoint();				
		}
	}
			
	function add_ordonnée(){   
		if (document.getElementById('ordonnée').value!='') { 
		Point_y = document.getElementById('ordonnée').value;									
				blackpoint_ordonnee = "OK";
				drawblackpoint();				
		}
	}
	
	function drawblackpoint(){

		if ((blackpoint_ordonnee == "OK")&&(blackpoint_abscisse=="OK")){
			d3.selectAll("path").remove();
			d3.select("#p_a5").remove();
			d3.select("#p_p4").remove();
			d3.selectAll("line").remove();
			d3.selectAll("text").remove();
			d3.select("#Badpointcircle").remove();
			drawperceptronline_finalErrorRate(TabWcostmin,"orange",4, 5);
			d3.select('#zone2').append("text").attr("id","p_t4").style("font-family","Arial").style("font-size","15px").text("Lorsque vous avez validé ");		
			d3.select('#zone2').append("text").attr("id","p_t5").style("font-family","Arial").style("font-size","15px").style("font-weight","bold").text("les deux coordonnées");		
			d3.select('#zone2').append("text").attr("id","p_t6").style("font-family","Arial").style("font-size","15px").text(", le point que vous avez choisi apparaît en noir sur le graphique. N'hésitez pas à faire plusieurs essais.");		

			d3.selectAll("#blkpt").remove();
			d3.selectAll("svg")
				.append("circle")
				.attr("id","blkpt")
				.style("stroke", "black")
				.style("fill", "gray")
				.style("opacity", 1)
				.attr("r", 5)
				.attr("cx",Point_x)
				.attr("cy",Point_y);
			diagnostic();
			blackpoint_abscisse = "KO";
			blackpoint_ordonnee = "KO";
			
		}
	}
	
	function diagnostic(){
	
		var x_pt = Point_x - 200;
		var y_pt = Point_y - 200;
		if(y_pt> (x_pt*slopeW+lineoffsetW)){
			var couleur_label = "rouge";
			d3.selectAll("#p_final").remove();
			d3.select("#zone2").append("p").attr("id","p_final").text("Le point de coordonnées x = "+Point_x+" et y = "+Point_y+" appartient au groupe "+ couleur_label+".").style("color","red");		
		}
		else{
			var couleur_label = "bleu";
			d3.selectAll("#p_final").remove();
			d3.select("#zone2").append("p").attr("id","p_final").text("Le point de coordonnées x = "+Point_x+" et y = "+Point_y+" appartient au groupe "+ couleur_label+".").style("color", "blue");		
		}
		
		
		
	}
	
	function Lancer_Kmeans(){
		//d3.selectAll("p").remove();
		d3.select("#p_p42").remove();
		d3.select("#p_p43").remove();
		d3.selectAll("rect").remove();
		d3.selectAll("text").remove();
		d3.selectAll("button").remove();
		d3.selectAll("line").remove();
		d3.selectAll("circle").remove();
		d3.selectAll("path").remove();
		d3.selectAll("path.area").remove();
		d3.select("#p_fin1").remove();
		d3.select("#p_fin2").remove();
		d3.select("#p_a1").remove();
		d3.select("#p_a2").remove();
		d3.select("#p_a3").remove();
		d3.select("#p_a4").remove();
		d3.select("#p_a5").remove();
		d3.select("#p_p01").remove();
		d3.select("#p_p02").remove();
		d3.select("#p_p03").remove();		
		d3.select("#p_p04").remove();
		d3.select("#p_p1").remove();
		d3.select("#p_p2").remove();
		d3.select("#p_p3").remove();
		d3.select("#p_p4").remove();
		d3.select("#p_f1").remove();
		d3.select("#p_f2").remove();
		d3.select("#p_f3").remove();
		d3.select("#p_f5").remove();
		d3.select("#p_t4").remove();
		d3.select("#p_t5").remove();
		d3.select("#p_t6").remove();
		d3.select("#p31").remove();
		d3.select("#p32").remove();
		d3.select("#p33").remove();
		d3.select("#p35").remove();
		d3.selectAll("#p_final").remove();
		d3.select("#p5").remove();
		d3.selectAll("h4").remove();
		d3.selectAll("g").remove();
		d3.select("#costpath").remove();
		d3.select("#Badpointcircle").remove();
		d3.select("#nValue").remove();
		d3.selectAll("label").remove();	
		d3.selectAll("br").remove();	
		d3.select("#buttonChoixPoints").remove();
		d3.select("#buttonChoixAbscisse").remove();
		d3.select("#buttonChoixOrdonnée").remove();				
		d3.select("#abscisse").remove();
		d3.select("#ordonnée").remove();
	
	
		var node = document.createElement('div'); 
		node.innerHTML = '<br /><label for="nValue" style="display: inline-block; width:225px; text-align: left; font-size: 15px; font-family: Arial; margin-left: 14px"> Choisir le nombre de points:    </label><input type="number" min="50" max="1000" step="10" value="500" id="nValue"><input value="valider" type="button"  onClick="add()" id="buttonChoixPoints">';	
		document.getElementById('lancement').appendChild(node);
	
		//Reinitialiser toutes les variables globales
		bubbleChart = [];	
		Yn = [];		
		P = [];		
		slope = 0;
		lineoffset = 0;
		
		Etat_points = "Choix_en_cours";
		valide = "valide";
		test = 0;
		Ok_pour_perceptron = "KO";
		W = [[]];
		slopeW = 0;
		lineoffsetW = 0;
		W[0] =  [0, 0, 0,0];
		IT = 0;
		XRn = 0;
		YRn = 0;
		YnRn = 0;
		Yn_w = [];
		Wcost = 0;
		Wcostmin = 5000;
		var TabWcostmin = [];
		tabl1=[];
		paddingy = 30;
		paddingx = 30;
		hx = 300;
		hy = 300;	
		Decalage_right_courbeCout = 550;
		formatAsPercentage = d3.format(".1%");
		xScale = d3.scale.linear();
		yScale = d3.scale.linear();
		w = 500;
		Costdataset = [];
		MaxIT = 1000;
		firsttime = "OK";
		Point_x = 0;
		Point_y = 0;
		blackpoint_ordonnee = "KO";
		blackpoint_abscisse  = "KO";
		Lambda = 0.1;
		coord_origine  = [];
		centroide[[]];
		affectation_points_centroides = [];	
		convergence = "ko"
		oneshot = "ko"
		
		d3.selectAll("svg").append("rect")
			.style("fill", "lavender")
			.attr("opacity", 0.4)
			.attr("stroke", "black")
			.attr("stroke-width", 1)
			.attr("width", 400)
			.attr("height", 400);		
	
		d3.select("#btn2")
			.on("click",function() {
				if(this.value == "Choisir les points") {
					this.value = "Changer les points";
					d3.select(this).text("Changer les points");
					runCircles();			
					validation_point();		
					d3.select("#pnumPoints").remove();					
					
				}
				else {
					runCircles();
				}
		});
		
		d3.select("svg2").append("h4").attr("id","p6").text("Phase de préparation des données").style("font-size", "17px");		
		d3.select("svg2").append("p").attr("id","p_p01").style("font-family","Arial").style("font-size","15px").text(" L'interface ci-dessous vous permet de créer vous même le jeu de données d'apprentissage. Chaque point est une mesure et les coordonnées de ces points sont les valeurs des variables explicatives.");	
		d3.select("svg2").append("p").attr("id","p_p02").style("font-family","Arial").style("font-size","15px").text(" Cette simplification permet de visualiser graphiquement le fonctionnement de l'algorithme, mais dans les cas réels les enregistrements sont identifiés par des milliers voire des centaines de milliers de caractéristiques, on parle d'espace de dimension p.");	

		
	}

	function Prédiction(){
	
		d3.select('#zone2').append("h4").text("Phase de prédiction").style("font-size", "17px");					
		d3.select('#zone2').append("p").attr("id","p_f1").style("font-family","Arial").style("font-size","15px").text("Lorsque vous saisissez les coordonnées d'un nouveau point, K-means est capable d'identifier son groupe d'appartenance. C'est celui du centroide le plus proche");	
		d3.select('#zone2').append("p").attr("id","p_f2").style("font-family","Arial").style("font-size","15px").text("L'axe des abscisses est de la gauche vers la droite sur le graphique.");	
		d3.select('#zone2').append("p").attr("id","p_f3").style("font-family","Arial").style("font-size","15px").text("L'axe des ordonnées est du haut vers le bas sur le graphique.");
			
		var node2 = document.createElement('div'); 
		node2.innerHTML = '<br /><label for="abscisse" style="display: inline-block; width:250px; text-align: left; font-size: 15px; font-family: Arial; margin-left: 14px">  Choisir une abscisse entre 0 et 400: </label><input type="number" min="0" max="400" step="10" value="50" id="abscisse"><input value="valider" type="button"  onClick="add_abscisse()" id="buttonChoixAbscisse">'+
		'<br /><br /><label for="ordonnée" style="display: inline-block; width:250px; text-align: left; font-size: 15px; font-family: Arial; margin-left: 14px">  Choisir une ordonnée entre 0 et 400: </label><input type="number" min="0" max="400" step="10" value="50" id="ordonnée"><input value="valider" type="button"  onClick="add_ordonnée()" id="buttonChoixOrdonnée"><br /><br />';	
		document.getElementById('zone2').appendChild(node2);
		
		d3.select('#zone2').append("text").attr("id","p_t4").style("font-family","Arial").style("font-size","15px").text("Lorsque vous avez validé ");		
		d3.select('#zone2').append("text").attr("id","p_t5").style("font-family","Arial").style("font-size","15px").style("font-weight","bold").text("les deux coordonnées");		
		d3.select('#zone2').append("text").attr("id","p_t6").style("font-family","Arial").style("font-size","15px").text(", le point que vous avez choisi apparaît en noir sur le graphique. N'hésitez pas à faire plusieurs essais.");		

		
		d3.select('#zone3').append("p").attr("id","p_f5").style("font-family","Arial").style("font-size","15px").text("Cet exercice peut sembler trivial en deux dimensions mais il faut savoir que dans les cas réels les points ont bien plus que deux ou trois coordonnées, les enregistrements peuvent avoir des milliers d'attributs. Or K-means s'adapte très facilement aux espaces de dimension n, n pouvant être très grand. Le sous espace de séparation n'est alors plus une droite mais un hyperplan de dimension n-1. Ce qui n'est plus représentable pour l'homme mais n'est pas plus compliqué pour l'algorithme.");		
	
		d3.select('#zone3').append("h4").text("Les points forts et les points faibles de K-means").style("font-size", "17px");					
		d3.select('#zone3').append("p").attr("id","p31").style("font-family","Arial").style("font-size","15px").text("Une première remarque valable pour tout algorithme d'apprentissage automatique: L'algorithme ne peut révéler une structure dans des données que s'il en existe une, cela suppose une organisation intrinsèque des données, ce qui n'est pas toujours le cas.");	
		d3.select('#zone3').append("p").attr("id","p32").style("font-family","Arial").style("font-size","15px").text("K-means a pour point fort sa simplicité alorithmique, il peut s'implémenter par ajout de nouveaux enregistrements au fil de l'eau(on parle l'algorythme 'on line'), sa performance s'améliorera alors au fur et à mesure de l'acquisition des données. Il a besoin toutefois d'un jeu de départ assez important pour commencer à etre efficace");	
		d3.select('#zone3').append("p").attr("id","p33").style("font-family","Arial").style("font-size","15px").text("Cet algorithme nécessite de parcourir tous les points de l'échantillon d'apprentissage et peut donc être gourmand en temps de calcul. Mais il a aussi l'avantage de faire à chaque itération le même traitement sur chaque  point et est donc facilement parallélisable.");	

	}
	
	Lancer_Kmeans();
		
    </script>
	
</body>
</html>